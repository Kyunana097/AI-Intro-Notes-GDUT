# 3.1 推理的基本概念

## 3.1.1 推理的定义

​**​推理​**​（reasoning）是指系统利用已有知识（如事实、规则、模型、经验等）对新的输入、问题或情境进行分析、判断和推导，从而得出合理结论或做出决策的过程。它是人工智能实现"智能行为"的核心机制之一，体现了系统对知识的理解、应用和生成能力。

​**​推理的基本要素​**​：

- 前提：已知的事实、规则或条件
    
- 结论：通过推理得到的新知识或判断
    
- 推理规则：连接前提和结论的逻辑关系

## 3.1.2 推理方式及其分类

### 1. ​**​按推理的逻辑基础分类​**​

#### (1) 演绎推理

从一般到个别的推理过程，结论必然蕴含在前提中

- ​**​三段论式​**​（三段论法）：大前提→小前提→结论
    
- ​**​假言推理​**​：如果P则Q，P为真，则Q为真
    
- ​**​特点​**​：保真性，前提真则结论必真
    

#### (2) 归纳推理

从个别到一般的推理过程，结论可能超出前提范围

- ​**​完全归纳推理​**​：考察所有个体后得出结论（必然性推理）
    
- ​**​不完全归纳推理​**​：考察部分个体后得出结论（非必然性推理）
    
- ​**​特点​**​：结论具有或然性，可能被新证据推翻
    

#### (3) 默认推理

- 知识不完全的情况下假设某些条件已经具备所进行的推理
    
- ​**​特点​**​：基于合理假设，但结论可能被新信息修正
    

### 2. ​**​按推理的确定性分类​**​

#### (1) 确定性推理

推理时所用的知识与证据都是确定的，推出的结论也是确定的，其真值或者为真或者为假。

#### (2) 不确定性推理

推理时所用的知识与证据不都是确定的，推出的结论也是不确定的。

- ​**​处理方法​**​：概率推理、模糊推理、证据理论等
    

### 3. ​**​按推理的单调性分类​**​

#### (1) 单调推理

如果系统每步推出的结论​**​一旦成立永远成立​**​，不会因后续加入新知识而被撤销或修改。

#### (2) 非单调推理

当新知识加入后，​**​原有结论可能被否定、撤销或修正​**​。

- ​**​应用场景​**​：常识推理、缺省推理等
    

### 4. ​**​按推理的启发性分类​**​

#### (1) 启发性推理

基于经验规则、启发式信息的推理，效率高但不保证最优

- ​**​特点​**​：利用领域知识，有针对性搜索
    

#### (2) 非启发性推理

按照一般性原理和规则进行推理，保证正确性但效率较低

## 3.1.3 推理的方向

### 1. ​**​正向推理​**​

从已知事实出发，正向使用规则进行推理

- ​**​适用场景​**​：初始信息明确，目标开放的问题
    

### 2. ​**​逆向推理​**​

从目标结论出发，反向寻找支持证据

- ​**​适用场景​**​：目标明确，需要验证假设的问题
    

### 3. ​**​混合推理​**​

结合正向和逆向推理，提高推理效率

### 4. ​**​双向推理​**​

正向推理与逆向推理同时进行，在推理过程中的某一步骤上"碰头"

## 3.1.4 冲突消解策略

### 已知事实与知识的匹配情况

1. ​**​一对一匹配​**​：恰好匹配成功
    
2. ​**​匹配失败​**​：不能匹配成功
    
3. ​**​多重匹配​**​：多种匹配成功（一对多、多对一、多对多）

### 冲突消解策略

1. ​**​按针对性排序​**​：选择条件更具体的规则
    
2. ​**​按已知事实的新鲜性排序​**​：优先使用新产生的事实
    
3. ​**​按匹配度排序​**​：选择匹配程度高的规则
    
4. ​**​按条件个数排序​**​：优先使用条件较少的规则
    
5. ​**​按上下文排序​**​：根据当前上下文选择最合适的规则
    
6. ​**​按规则优先级排序​**​：预先设定规则优先级

# 3.2 自然演绎推理

## 一、核心概念

自然演绎推理是一种基于逻辑规则的推理方法，核心是从​**​前提​**​出发，通过一系列符合逻辑的推理规则，逐步推导出​**​结论​**​，不依赖公理，更贴近人类自然的推理思维。

## 二、常见推理规则（以命题逻辑为例）

### 1. 联结词规则

#### （1）合取（∧）规则

- ​**​引入规则（∧+）​**​：若已推出A和B，则可推出A∧B
    
- ​**​消去规则（∧-）​**​：若已推出A∧B，则可推出A，也可推出B

#### （2）析取（∨）规则

- ​**​引入规则（∨+）​**​：若已推出A，则可推出A∨B
    
- ​**​消去规则（∨-）​**​：若已推出A∨B，且由A可推出C、由B可推出C，则可推出C

#### （3）蕴含（→）规则

- ​**​引入规则（→+）​**​：若假设A为真，能推出B，则可推出A→B
    
- ​**​消去规则（→-，假言推理）​**​：若已推出A→B和A，则可推出B

#### （4）否定（¬）规则

- ​**​矛盾规则（¬+）​**​：若假设A为真，推出矛盾，则可推出¬A
    
- ​**​双重否定消去（¬-）​**​：若已推出¬¬A，则可推出A
### 2. 结构规则

- ​**​前提引入​**​：推理中可随时引入已知前提
    
- ​**​结论引用​**​：推理中可引用已推出的中间结论

## 三、推理过程与策略

### 1. ​**​正向推理​**​

从前提出发，逐步应用规则推导结论

### 2. ​**​反向推理​**​

从结论倒推，思考"需满足什么条件才能推出结论"

### 3. ​**​推理示例​**​

前提：A→B，A∧C

结论：B∧C

​**​推理步骤​**​：

① 由A∧C（前提），用∧-推出A

② 由A→B（前提）和①的A，用→-推出B

③ 由A∧C（前提），用∧-推出C

④ 由②的B和③的C，用∧+推出B∧C（结论）

## 四、注意事项

1. ​**​规则有效性​**​：每一步推理必须严格符合规则
    
2. ​**​假设消去​**​：通过→+或¬+引入的假设必须消去
    
3. ​**​矛盾识别​**​：归谬法中需明确推出逻辑矛盾
    

# 3.3 谓词公式化为子句集的方法

## 一、基础概念

- ​**​子句​**​：由原子谓词公式及其否定通过析取连接而成的公式
    
- ​**​空子句​**​：不含任何文字的子句，代表矛盾
    
- ​**​子句集​**​：由子句构成的集合
    

## 二、核心转化步骤（7步）

### 步骤1：消除蕴含（→）和等价（↔）联结词

利用逻辑等价式：A→B ≡ ¬A∨B、A↔B ≡ (A→B)∧(B→A)

### 步骤2：将否定（¬）符号移到原子谓词公式前

应用德摩根定律和量词否定等价式

### 步骤3：标准化变元

确保每个量词的约束变元名称唯一

### 步骤4：消去存在量词（Skolem化）

- 存在量词前有全称量词：用Skolem函数替换
    
- 存在量词在最外层：用Skolem常量替换
    

### 步骤5：将所有全称量词移到公式最前端（前束范式）

### 步骤6：将母式化为合取范式（CNF）

应用分配律A∨(B∧C)≡(A∨B)∧(A∨C)

### 步骤7：消去合取符号，得到子句集

## 三、转化示例

原公式：∃x∀y[P(x,y)→¬(∀zQ(y,z)→R(x))]

转化过程：

1. 消除蕴含：∃x∀y[¬P(x,y)∨¬(¬∀zQ(y,z)∨R(x))]
    
2. 否定内移：∃x∀y[¬P(x,y)∨(∀zQ(y,z)∧¬R(x))]
    
3. Skolem化：∀y[¬P(a,y)∨(∀zQ(y,z)∧¬R(a))]
    
4. 前束范式：∀y∀z[¬P(a,y)∨(Q(y,z)∧¬R(a))]
    
5. 合取范式：(¬P(a,y)∨Q(y,z))∧(¬P(a,y)∨¬R(a))
    
6. 子句集：{¬P(a,y)∨Q(y,z), ¬P(a,y)∨¬R(a)}
# 3.4 鲁滨逊归结原理

## 一、基本思想

​**​鲁滨逊归结原理​**​由J. Alan Robinson于1965年提出，是自动定理证明的基础。其核心思想是通过​**​消去互补文字​**​来简化子句集，最终推导出空子句（□），从而证明原公式的不可满足性。

## 二、基本概念

### 1. ​**​文字与子句​**​

- ​**​文字​**​：原子谓词或其否定
    
- ​**​子句​**​：文字的析取式
    
- ​**​空子句​**​：不含任何文字，代表​**​矛盾​**​
    

### 2. ​**​互补文字​**​

如果两个文字具有相同的谓词符号但符号相反，则称为互补文字。

例：P(x) 与 ¬P(x) 为互补文字

## 三、归结推理规则

### 1. ​**​命题逻辑的归结​**​

对于两个子句：

- C₁: P ∨ Q₁ ∨ Q₂ ∨ ... ∨ Qₘ
    
- C₂: ¬P ∨ R₁ ∨ R₂ ∨ ... ∨ Rₙ
    

​**​归结式​**​：Q₁ ∨ ... ∨ Qₘ ∨ R₁ ∨ ... ∨ Rₙ

### 2. ​**​一阶谓词逻辑的归结​**​

需要先进行​**​合一​**​操作，使两个文字成为互补文字。

​**​归结过程​**​：

1. 选择两个含有互补文字的子句
    
2. 通过合一置换使文字互补
    
3. 应用归结规则
    
4. 将归结式加入子句集
    

## 四、合一算法

### 1. ​**​合一的概念​**​

找到一种变量置换，使两个表达式变得相同。

### 2. ​**​合一算法步骤​**​

- 检查两个表达式是否相同
    
- 如果不同，寻找差异集
    
- 尝试消解差异
    
- 递归应用直到合一成功或失败
    

​**​示例​**​：

合一 P(f(x), y) 和 P(f(a), g(b))

- 差异集：{x/a, y/g(b)}
    
- 合一结果：{x/a, y/g(b)}
    

## 五、归结推理过程

`def resolution(clause_set):     while True:         # 选择两个子句进行归结         for i in range(len(clause_set)):             for j in range(i+1, len(clause_set)):                 # 寻找互补文字                 resolvent = resolve(clause_set[i], clause_set[j])                 if resolvent == []:  # 空子句                     return True  # 证明完成                 elif resolvent not in clause_set:                     clause_set.append(resolvent)         return False  # 无法证明`

# 3.5 归结反演

## 一、基本思想

​**​归结反演​**​是一种基于反证法的证明方法：要证明公式G成立，只需证明¬G与已知前提集合一起构成不可满足的子句集。

## 二、反演过程

### 1. ​**​证明步骤​**​

1. 将前提条件化为子句集 S
    
2. 将结论的否定 ¬G 化为子句集
    
3. 合并得到待证明的子句集 S ∪ {¬G}
    
4. 应用归结原理进行推导
    
5. 如果推出空子句，则证明G成立
    

### 2. ​**​形式化描述​**​

已知：前提集合 F = {F₁, F₂, ..., Fₙ}

求证：G

等价于证明：F → G 永真

即证明：¬(F → G) = F ∧ ¬G 不可满足

## 三、反演树

### 1. ​**​构造方法​**​

- 根节点：目标结论的否定
    
- 中间节点：归结产生的子句
    
- 叶节点：前提子句或公理
    
- 终止条件：产生空子句
    

### 2. ​**​示例​**​

​**​前提​**​：

1. ∀x (P(x) → Q(x))
    
2. P(a)
    

​**​求证​**​：Q(a)

​**​反演证明​**​：

1. 化为子句集：
    
    - ¬P(x) ∨ Q(x) [来自前提1]
        
    - P(a) [来自前提2]
        
    - ¬Q(a) [结论的否定]
        
    
2. 归结过程：
    
    - ¬P(x) ∨ Q(x) 与 P(a) 归结：{x/a} → Q(a)
        
    - Q(a) 与 ¬Q(a) 归结：□
        
    

## 四、控制策略

### 1. ​**​广度优先策略​**​

- 系统性地生成所有可能的归结式
    
- 保证完备性但效率较低
    

### 2. ​**​支持集策略​**​

- 优先使用目标结论相关的子句
    
- 提高搜索效率
    

### 3. ​**​单元优先策略​**​

- 优先使用单文字子句进行归结
    
- 快速简化子句集
    

# 3.6 应用归结反演求解问题

## 一、问题求解框架

### 1. ​**​问题描述​**​

将实际问题转化为逻辑公式表达：

- 已知条件：前提公式
    
- 目标状态：结论公式
    
- 操作规则：蕴含关系
    

### 2. ​**​求解步骤​**​

1. 问题形式化：用谓词逻辑描述问题
    
2. 化为子句集：应用3.3节的方法
    
3. 归结反演：应用3.5节的方法
    
4. 答案提取：从证明过程中提取解
    

## 二、典型应用示例

### 示例1：猴子香蕉问题

​**​问题描述​**​：

- 猴子在位置a
    
- 香蕉挂在位置c的天花板上
    
- 盒子在位置b
    
- 猴子需要拿到香蕉
    

​**​谓词描述​**​：

`at(monkey, a) at(box, b) at(banana, c) can_reach(monkey, banana) ← at(monkey, x) ∧ at(box, x) ∧ at(banana, x)`

​**​归结求解过程​**​：

1. 将问题描述化为子句集
    
2. 加入目标：can_reach(monkey, banana)
    
3. 应用归结反演求证明
    
4. 从证明中提取动作序列
    

### 示例2：家族关系推理

​**​已知​**​：

1. ∀x∀y (father(x,y) → parent(x,y))
    
2. ∀x∀y (mother(x,y) → parent(x,y))
    
3. parent(John, Mary)
    
4. ∀x∀y (parent(x,y) → ancestor(x,y))
    
5. ∀x∀y∀z (ancestor(x,y) ∧ ancestor(y,z) → ancestor(x,z))
    

​**​求证​**​：ancestor(John, Mary) 的某个后代

​**​求解过程​**​：

1. 化为子句集
    
2. 构造反演证明
    
3. 提取具体的后代个体
    

## 三、答案提取方法

### 1. ​**​证明树分析​**​

- 分析归结证明树的结构
    
- 追踪变量的绑定过程
    
- 提取具体的解实例
    

### 2. ​**​回答语句构造​**​

从证明过程中构造回答谓词：

- 记录归结过程中的变量置换
    
- 生成具体的答案实例
    

### 3. ​**​示例​**​（家族关系）

证明 ancestor(John, z) 的过程中：

- 通过归结得到 z 与 Mary 或其他人的关系
    
- 提取具体的 z 值作为答案
    

## 四、实际应用考虑

### 1. ​**​效率优化​**​

- 使用启发式策略指导归结
    
- 限制搜索空间大小
    
- 采用增量式证明方法
    

### 2. ​**​实用性限制​**​

- 组合爆炸问题
    
- 适用于小规模问题
    
- 实际系统中常与其他方法结合
    

### 3. ​**​扩展应用​**​

- 自动程序设计
    
- 智能问答系统
    
- 知识库推理验证